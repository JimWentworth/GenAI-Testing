<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GenAI Model Taxonomy Playground</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      font-size: 16px;
      --bg: #f7f8fb;
      --navy: #13294b;
      --navy-soft: #1f3d7a;
      --orange: #e84a27;
      --panel: #ffffff;
      --panel-border: rgba(19, 41, 75, 0.12);
      --panel-shadow: 0 18px 40px rgba(19, 41, 75, 0.08);
      --text: #1f2933;
      --muted: #5f6c80;
      --accent-soft: rgba(232, 74, 39, 0.1);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Lexend', system-ui, sans-serif;
      background: linear-gradient(180deg, var(--bg) 0%, #eef1f7 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 2.75rem 5vw 2.5rem;
      display: grid;
      gap: 1.1rem;
      background: linear-gradient(135deg, var(--navy) 0%, var(--navy-soft) 65%, #1d478b 100%);
      color: #f7f9ff;
      position: relative;
      overflow: hidden;
    }

    header p {
      color: rgba(247, 249, 255, 0.82);
    }

    header::after {
      content: "";
      position: absolute;
      inset: 15% 15% auto;
      height: 200px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.2), transparent 65%);
      filter: blur(45px);
      z-index: 0;
    }

    header > * {
      position: relative;
      z-index: 1;
    }

    h1 {
      font-size: clamp(2.4rem, 4vw + 1.2rem, 4rem);
      margin: 0;
      line-height: 1.05;
      letter-spacing: -0.02em;
    }

    h2 {
      font-size: 1.6rem;
      margin-bottom: 0.35rem;
      color: var(--navy);
    }

    p {
      margin: 0;
      color: var(--muted);
      line-height: 1.6;
    }

    main {
      padding: 0 5vw 5rem;
      display: grid;
      gap: 2rem;
    }

    .pill-tray {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .tag-pill {
      background: rgba(255, 255, 255, 0.2);
      color: #f7f9ff;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      border: 1px solid rgba(255, 255, 255, 0.3);
      text-decoration: none;
      font-weight: 500;
      letter-spacing: 0.01em;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
    }

    .tag-pill:hover,
    .tag-pill:focus {
      background: rgba(255, 255, 255, 0.28);
      border-color: rgba(255, 255, 255, 0.45);
      transform: translateY(-1px);
    }

    .tag-pill:focus-visible {
      outline: 2px solid rgba(255, 255, 255, 0.85);
      outline-offset: 3px;
    }

    .panel {
      background: var(--panel);
      border-radius: 22px;
      padding: 1.9rem;
      border: 1px solid var(--panel-border);
      box-shadow: var(--panel-shadow);
      position: relative;
      overflow: hidden;
    }

    .panel h2 {
      margin-top: 0;
    }

    .intro-panel {
      display: grid;
      gap: 1.2rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(239, 244, 252, 0.92));
    }

    .intro-panel p {
      color: var(--text);
    }

    .intro-list {
      margin: 0;
      padding-left: 1.1rem;
      display: grid;
      gap: 0.6rem;
      color: var(--muted);
    }

    .intro-list strong {
      color: var(--navy);
    }

    .panel-grid {
      display: grid;
      gap: 1.8rem;
    }

    @media (min-width: 1200px) {
      .panel-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .gallery-grid {
      display: grid;
      gap: 1.2rem;
    }

    @media (min-width: 900px) {
      .gallery-grid {
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }
    }

    .model-card {
      background: #fefefe;
      border: 1px solid rgba(19, 41, 75, 0.12);
      padding: 1.3rem;
      border-radius: 18px;
      display: grid;
      gap: 0.85rem;
      position: relative;
      min-height: 220px;
      box-shadow: 0 16px 30px rgba(19, 41, 75, 0.08);
    }

    .model-card::after {
      content: attr(data-year);
      position: absolute;
      top: 1rem;
      right: 1rem;
      font-size: 0.85rem;
      color: var(--navy);
      background: rgba(19, 41, 75, 0.08);
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
    }

    .model-card h3 {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: -0.01em;
      color: var(--navy);
    }

    .model-card ul {
      margin: 0;
      padding-left: 1.1rem;
      color: var(--muted);
      font-size: 0.95rem;
    }

    section[id] {
      scroll-margin-top: 6rem;
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1rem 0 1.5rem;
    }

    .filter-chip {
      border: 1px solid rgba(19, 41, 75, 0.18);
      padding: 0.45rem 0.85rem;
      border-radius: 12px;
      background: rgba(19, 41, 75, 0.04);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.92rem;
      color: var(--navy);
    }

    .filter-chip.active {
      background: rgba(232, 74, 39, 0.12);
      color: var(--orange);
      border-color: rgba(232, 74, 39, 0.35);
      box-shadow: 0 8px 18px rgba(232, 74, 39, 0.2);
    }

    .controls {
      display: grid;
      gap: 1.4rem;
    }

    @media (min-width: 900px) {
      .controls {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .control-card {
      background: rgba(19, 41, 75, 0.04);
      border: 1px solid var(--panel-border);
      padding: 1.2rem 1.35rem;
      border-radius: 16px;
      display: grid;
      gap: 0.85rem;
    }

    .control-card strong {
      font-weight: 600;
      color: var(--navy);
    }

    .control-card label {
      font-size: 0.92rem;
      color: var(--muted);
    }

    select, input[type="range"] {
      width: 100%;
      padding: 0.65rem;
      border-radius: 12px;
      border: 1px solid rgba(19, 41, 75, 0.25);
      background: #f8f9fb;
      color: var(--text);
      font-family: inherit;
    }

    .range-value {
      font-weight: 600;
      font-size: 1.05rem;
      color: var(--navy);
    }

    .lineage-path {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      margin-top: 0.5rem;
    }

    .lineage-node {
      padding: 0.4rem 0.7rem;
      border-radius: 999px;
      background: rgba(19, 41, 75, 0.08);
      border: 1px solid rgba(19, 41, 75, 0.18);
      font-size: 0.9rem;
      color: var(--navy);
    }

    .lineage-node.current {
      background: rgba(232, 74, 39, 0.14);
      color: var(--orange);
      font-weight: 600;
      border-color: rgba(232, 74, 39, 0.4);
    }

    .arrow {
      color: rgba(19, 41, 75, 0.4);
      font-size: 1rem;
    }

    .term-grid {
      display: grid;
      gap: 1.2rem;
    }

    @media (min-width: 1000px) {
      .term-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    .term-card {
      background: #f8f9fb;
      border: 1px solid rgba(19, 41, 75, 0.12);
      padding: 1.1rem;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 12px 24px rgba(19, 41, 75, 0.08);
    }

    .term-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(232, 74, 39, 0.08), transparent 60%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .term-card:hover::before {
      opacity: 1;
    }

    .term-card h3 {
      margin-top: 0;
      margin-bottom: 0.35rem;
      color: var(--navy);
    }

    .term-card p {
      font-size: 0.95rem;
      color: var(--muted);
    }

    .term-card .tip {
      margin-top: 0.75rem;
      font-size: 0.82rem;
      color: var(--orange);
      display: inline-block;
      border: 1px solid rgba(232, 74, 39, 0.35);
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: rgba(232, 74, 39, 0.08);
    }

    .scenario-pills {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .scenario-pill {
      border-radius: 999px;
      border: 1px solid rgba(19, 41, 75, 0.18);
      background: rgba(19, 41, 75, 0.05);
      color: var(--navy);
      padding: 0.5rem 1.1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.95rem;
    }

    .scenario-pill.active {
      background: rgba(232, 74, 39, 0.14);
      color: var(--orange);
      box-shadow: 0 10px 20px rgba(232, 74, 39, 0.18);
      border-color: rgba(232, 74, 39, 0.35);
      font-weight: 600;
    }

    .scenario-content {
      margin-top: 1.1rem;
      display: grid;
      gap: 0.9rem;
    }

    .scenario-content ul {
      margin: 0;
      padding-left: 1.1rem;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .scenario-highlight {
      font-size: 1rem;
      color: var(--orange);
      background: rgba(232, 74, 39, 0.1);
      padding: 0.75rem 1rem;
      border-radius: 12px;
      border: 1px solid rgba(232, 74, 39, 0.28);
    }

    .tab-header {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    @media (min-width: 900px) {
      .tab-header {
        flex-direction: row;
        align-items: flex-end;
        justify-content: space-between;
      }
    }

    .tab-intro {
      margin: 0.4rem 0 0;
      color: rgba(19, 41, 75, 0.75);
    }

    .tab-buttons {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .tab-button {
      border: 1px solid rgba(19, 41, 75, 0.18);
      background: #ffffff;
      color: var(--navy);
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      background: var(--navy);
      color: #ffffff;
      border-color: var(--navy);
      box-shadow: 0 12px 24px rgba(19, 41, 75, 0.18);
    }

    .tab-content {
      display: none;
      margin-top: 1.5rem;
    }

    .tab-content.active {
      display: block;
    }

    .tab-description {
      margin-bottom: 1.25rem;
      color: var(--muted);
    }

    .drag-drop-container {
      display: grid;
      gap: 1.5rem;
    }

    @media (min-width: 1000px) {
      .drag-drop-container {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .draggable-list,
    .dropzone-list {
      display: grid;
      gap: 0.75rem;
    }

    .drag-item {
      padding: 0.6rem 0.9rem;
      border-radius: 12px;
      border: 1px solid rgba(19, 41, 75, 0.18);
      background: #ffffff;
      box-shadow: 0 10px 22px rgba(19, 41, 75, 0.1);
      cursor: grab;
      font-weight: 600;
      color: var(--navy);
      user-select: none;
    }

    .drag-item:active {
      cursor: grabbing;
    }

    .drag-item.assigned {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .dropzone {
      border: 2px dashed rgba(19, 41, 75, 0.2);
      border-radius: 14px;
      padding: 0.9rem 1rem;
      background: rgba(19, 41, 75, 0.05);
      min-height: 96px;
      display: grid;
      gap: 0.45rem;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .dropzone strong {
      color: var(--navy);
      font-size: 0.95rem;
    }

    .dropzone p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .drop-placeholder {
      font-style: italic;
      color: rgba(19, 41, 75, 0.55);
    }

    .dropzone.filled {
      border-style: solid;
      border-color: rgba(232, 74, 39, 0.35);
      background: rgba(232, 74, 39, 0.08);
    }

    .dropzone.drag-over {
      border-color: var(--navy);
      background: rgba(19, 41, 75, 0.12);
    }

    .dropzone.correct {
      border-color: rgba(36, 148, 79, 0.6);
      background: rgba(36, 148, 79, 0.12);
    }

    .dropzone.incorrect {
      border-color: rgba(232, 74, 39, 0.6);
      background: rgba(232, 74, 39, 0.15);
    }

    .check-button {
      margin-top: 1.5rem;
      padding: 0.7rem 1.45rem;
      border-radius: 12px;
      border: none;
      background: var(--navy);
      color: #ffffff;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .check-button:hover {
      background: #0f1e3b;
      transform: translateY(-1px);
    }

    .match-feedback {
      margin-top: 1rem;
      font-weight: 600;
      color: var(--navy);
    }

    footer {
      padding: 2rem 5vw 3rem;
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
      border-top: 1px solid rgba(19, 41, 75, 0.12);
      background: rgba(255, 255, 255, 0.6);
    }

    a {
      color: var(--orange);
    }
  </style>
</head>
<body>
  <header>
    <h1>GenAI Model Taxonomy Playground · UIUC Edition</h1>
    <p>Explore the ecosystems, training recipes, architectures, and lineages that shape today's generative AI landscape. Mix and match filters, follow family trees, and translate technical terminology into practical classroom language.</p>
    <p>This teaching companion was crafted for University of Illinois cohorts to ground GenAI vocabulary in authentic classroom moves, helping facilitators move from buzzwords to confident instruction.</p>
    <div class="pill-tray">
      <a class="tag-pill" href="#timeline-tools">Timeline Explorer</a>
      <a class="tag-pill" href="#model-gallery">Taxonomy Filters</a>
      <a class="tag-pill" href="#scenario-composer">Classroom Scenarios</a>
      <a class="tag-pill" href="#lineage-tools">Lineage Visualizer</a>
      <a class="tag-pill" href="#learning-activities">Learning Activities</a>
    </div>
  </header>

  <main>
    <section class="panel intro-panel" id="overview">
      <h2>What this playground is designed to do</h2>
      <p>Use this space as a guided lab where students translate abstract GenAI jargon into concrete decision making. Each module is tuned to show how model families, training strategies, and deployment patterns connect to instructional goals.</p>
      <ul class="intro-list">
        <li><strong>Connect taxonomy layers:</strong> Compare frameworks, architectures, and release years side-by-side to build intuition for why models behave differently.</li>
        <li><strong>Trace lineage:</strong> Follow model ancestry to surface how innovations ripple through families and what that means for classroom adoption.</li>
        <li><strong>Practice with scenarios:</strong> Challenge learners to match hints, compose lesson plans, and experiment with filters that mirror real teaching questions.</li>
      </ul>
    </section>

    <section class="panel" id="model-gallery">
      <h2>Interactive Model Gallery</h2>
      <p>Activate filters from any taxonomy dimension to watch the gallery reorganize in real time. This helps students see how the same model can be categorized through training strategy, architecture, or organizational lineage.</p>
      <div class="filters" id="filters"></div>
      <div class="gallery-grid" id="gallery"></div>
    </section>

    <section class="panel-grid">
      <section class="panel" id="timeline-tools">
        <h2>Control Deck</h2>
        <div class="controls">
          <div class="control-card" id="lineage-tools">
            <strong>Model Lineage Explorer</strong>
            <label for="lineage-select">Choose a model to view its ancestry and successors.</label>
            <select id="lineage-select"></select>
            <div class="lineage-path" id="lineage-path"></div>
          </div>
          <div class="control-card">
            <strong>Release Timeline</strong>
            <label for="timeline-slider">Slide to focus on models released through a specific year.</label>
            <input type="range" id="timeline-slider" min="2017" max="2025" value="2025" />
            <div class="range-value">Showing models released up to <span id="timeline-value">2025</span></div>
          </div>
        </div>
      </section>

      <section class="panel" id="scenario-composer">
        <h2>Scenario Composer</h2>
        <p>Pick a classroom scenario to surface the most relevant model traits and conversation starters. Each option offers quick prompts for educators to ground jargon in practical use cases.</p>
        <div class="scenario-pills" id="scenario-pills"></div>
        <div class="scenario-content" id="scenario-content"></div>
      </section>
    </section>

    <section class="panel" id="learning-activities">
      <div class="tab-header">
        <div>
          <h2>Learning Activities</h2>
          <p class="tab-intro">Choose an activity to help learners connect terminology with real-world reasoning tasks.</p>
        </div>
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="terminology">Terminology Playground</button>
          <button class="tab-button" data-tab="model-match">Model Match Drag &amp; Drop</button>
        </div>
      </div>
      <div class="tab-content active" id="terminology-tab">
        <p>Hover over a card to reveal design cues and analogies that make these technical ideas memorable for new AI explorers.</p>
        <div class="term-grid" id="term-grid"></div>
      </div>
      <div class="tab-content" id="model-match-tab">
        <p class="tab-description">Drag the model name that best matches each classroom-friendly hint. Click a hint to clear it if you want to try again.</p>
        <div class="drag-drop-container">
          <div class="draggable-list" id="model-draggables" aria-label="Model names to drag"></div>
          <div class="dropzone-list" id="model-dropzones" aria-label="Drop targets with hints"></div>
        </div>
        <button class="check-button" id="check-matches">Check my matches</button>
        <div class="match-feedback" id="match-feedback"></div>
      </div>
    </section>
  </main>

  <footer>
    Designed to help students and educators build intuition about generative AI systems. Updated May 2024. Crafted by the CITL innovation sandbox.
  </footer>

  <script>
    const models = [
      {
        name: 'GPT-4o',
        family: 'OpenAI GPT',
        architecture: 'Decoder Transformer',
        training: ['Supervised Fine-Tuning', 'Reinforcement Learning from Human Feedback', 'Multimodal Alignment'],
        frameworks: ['OpenAI API', 'Azure OpenAI'],
        releaseYear: 2024,
        lineage: ['GPT-1', 'GPT-2', 'GPT-3', 'GPT-4', 'GPT-4o'],
        spotlight: 'Balanced for reasoning, tutoring, and multimodal storytelling.'
      },
      {
        name: 'GPT-3.5',
        family: 'OpenAI GPT',
        architecture: 'Decoder Transformer',
        training: ['Supervised Fine-Tuning', 'Reinforcement Learning from Human Feedback'],
        frameworks: ['OpenAI API', 'Azure OpenAI'],
        releaseYear: 2022,
        lineage: ['GPT-1', 'GPT-2', 'GPT-3', 'GPT-3.5'],
        spotlight: 'Fast response model ideal for brainstorming and formative feedback.'
      },
      {
        name: 'Claude 3 Opus',
        family: 'Anthropic Claude',
        architecture: 'Constitutional Transformer',
        training: ['Constitutional AI', 'Contrastive Preference Optimization'],
        frameworks: ['Anthropic Console', 'Amazon Bedrock'],
        releaseYear: 2024,
        lineage: ['Claude 1', 'Claude 2', 'Claude 3', 'Claude 3 Opus'],
        spotlight: 'Excels at safety-sensitive tutoring and long-form reasoning.'
      },
      {
        name: 'Claude 3 Haiku',
        family: 'Anthropic Claude',
        architecture: 'Constitutional Transformer',
        training: ['Constitutional AI', 'Contrastive Preference Optimization'],
        frameworks: ['Anthropic Console', 'Amazon Bedrock'],
        releaseYear: 2024,
        lineage: ['Claude 1', 'Claude 2', 'Claude 3 Haiku'],
        spotlight: 'Lightweight and fast—great for on-the-fly classroom checks for understanding.'
      },
      {
        name: 'Gemini 1.5 Pro',
        family: 'Google Gemini',
        architecture: 'Multimodal Mixture-of-Experts',
        training: ['Distillation', 'Reinforcement Learning from Human Feedback'],
        frameworks: ['Google AI Studio', 'Vertex AI'],
        releaseYear: 2024,
        lineage: ['PaLM', 'PaLM 2', 'Gemini 1.0', 'Gemini 1.5 Pro'],
        spotlight: 'Powerful multimodal reasoning across text, images, and video.'
      },
      {
        name: 'Gemini 1.5 Flash',
        family: 'Google Gemini',
        architecture: 'Multimodal Mixture-of-Experts',
        training: ['Distillation', 'Reinforcement Learning from Human Feedback'],
        frameworks: ['Google AI Studio', 'Vertex AI'],
        releaseYear: 2024,
        lineage: ['PaLM', 'PaLM 2', 'Gemini 1.0', 'Gemini 1.5 Flash'],
        spotlight: 'Optimized for cost-efficient classroom pilots and rapid prototyping.'
      },
      {
        name: 'Llama 3 70B',
        family: 'Meta Llama',
        architecture: 'Decoder Transformer',
        training: ['Supervised Fine-Tuning', 'RLHF', 'Continual Pretraining'],
        frameworks: ['Hugging Face', 'AWS Bedrock'],
        releaseYear: 2024,
        lineage: ['LLaMA 1', 'LLaMA 2', 'Llama 3 70B'],
        spotlight: 'Open-weights option for institutions building bespoke tutors.'
      },
      {
        name: 'Mistral Large',
        family: 'Mistral AI',
        architecture: 'Dense Transformer',
        training: ['Instruction Tuning', 'Preference Optimization'],
        frameworks: ['Mistral API', 'Azure AI Studio'],
        releaseYear: 2024,
        lineage: ['Mistral 7B', 'Mixtral 8x7B', 'Mistral Large'],
        spotlight: 'European-born model with strong multilingual capabilities.'
      },
      {
        name: 'Mixtral 8x7B',
        family: 'Mistral AI',
        architecture: 'Mixture-of-Experts Transformer',
        training: ['Instruction Tuning', 'Sparse Activation Routing'],
        frameworks: ['Hugging Face', 'Mistral API'],
        releaseYear: 2023,
        lineage: ['Mistral 7B', 'Mixtral 8x7B'],
        spotlight: 'Hybrid approach combining efficiency with high quality responses.'
      },
      {
        name: 'Stable Diffusion XL',
        family: 'Stability AI',
        architecture: 'Latent Diffusion',
        training: ['Text-to-Image Alignment', 'Human-in-the-loop Curation'],
        frameworks: ['ComfyUI', 'Hugging Face'],
        releaseYear: 2023,
        lineage: ['Stable Diffusion 1.4', 'Stable Diffusion 2.0', 'Stable Diffusion XL'],
        spotlight: 'Image-first model illustrating how diffusion differs from transformers.'
      },
      {
        name: 'DALL·E 3',
        family: 'OpenAI DALL·E',
        architecture: 'Diffusion-Transformer Hybrid',
        training: ['Text-to-Image Alignment', 'Reinforcement Learning from Human Feedback'],
        frameworks: ['OpenAI API', 'Microsoft Designer'],
        releaseYear: 2023,
        lineage: ['DALL·E', 'DALL·E 2', 'DALL·E 3'],
        spotlight: 'Demonstrates how language-guided imagery expands beyond text-only models.'
      }
    ];

    const terminology = [
      {
        term: 'Model Family',
        definition: 'A group of models sharing a core design philosophy, training data inheritance, or research team.',
        analogy: 'Think of it as a franchise—each sequel adds new abilities but keeps the recognizable DNA.'
      },
      {
        term: 'Architecture',
        definition: 'The blueprint describing how a model processes information (transformer, diffusion, mixture-of-experts, etc.).',
        analogy: 'Like deciding if your classroom is arranged in rows, pods, or a makerspace—it shapes how work flows.'
      },
      {
        term: 'Training Strategy',
        definition: 'The process that teaches the model how to behave, including supervised fine-tuning, RLHF, or constitutional AI.',
        analogy: 'Professional development plans for AI: mentorship, coaching cycles, and ongoing refinement.'
      },
      {
        term: 'Framework Ecosystem',
        definition: 'Platforms and tools that provide access to the model, from APIs to hosted notebooks and cloud consoles.',
        analogy: 'The learning management system and classroom tech stack supporting your instruction.'
      },
      {
        term: 'Lineage',
        definition: 'The family tree tracing which earlier models paved the way for a current release.',
        analogy: 'A genealogy project for algorithms—spot the grandparent breakthroughs that changed the field.'
      },
      {
        term: 'Multimodal',
        definition: 'A capability where the model understands or generates more than text, such as images, audio, or video.',
        analogy: 'Like a student presentation that mixes slides, storytelling, and live demos.'
      },
      {
        term: 'Mixture-of-Experts',
        definition: 'A technique that routes inputs to specialized subnetworks, combining their outputs for efficiency and accuracy.',
        analogy: 'Inviting multiple specialists into a project-based class and calling on them only when needed.'
      },
      {
        term: 'Constitutional AI',
        definition: 'A training approach where models critique and refine their own responses using a written set of principles.',
        analogy: 'Students using a rubric to peer review and revise their own work before submitting.'
      },
      {
        term: 'Instruction Tuning',
        definition: 'Fine-tuning on examples of good instructions and responses so the model follows directions more faithfully.',
        analogy: 'Modeling “I do, we do, you do” for AI—plenty of exemplars before independent practice.'
      }
    ];

    const modelMatch = [
      {
        model: 'GPT-4o',
        hint: 'OpenAI release that pairs extended context with audio and vision for lively tutoring demos.'
      },
      {
        model: 'Claude 3 Haiku',
        hint: 'Anthropic model tuned for fast, budget-friendly classroom checks for understanding.'
      },
      {
        model: 'Llama 3 70B',
        hint: 'Open-weight option from Meta that universities can fine-tune for campus-specific copilots.'
      },
      {
        model: 'Gemini 1.5 Flash',
        hint: 'Google multimodal tier designed for cost-efficient prototyping and quick multimedia responses.'
      }
    ];


    const scenarios = {
      'Creative Writing Studio': {
        highlight: 'Spotlight narrative-friendly models and talk about multimodal storytelling.',
        recommendations: ['GPT-4o', 'Claude 3 Opus', 'DALL·E 3'],
        conversation: [
          'Compare how decoder transformers and diffusion models handle tone and imagery.',
          'Discuss why RLHF matters for collaborative creative drafting.',
          'Ask students to storyboard a multi-modal scene using text + visuals.'
        ]
      },
      'STEM Problem Solvers': {
        highlight: 'Emphasize reasoning depth, tool use, and safety frameworks for lab scenarios.',
        recommendations: ['Gemini 1.5 Pro', 'GPT-4o', 'Claude 3 Opus'],
        conversation: [
          'Contrast mixture-of-experts routing with dense transformer processing.',
          'Explain how constitutional AI adds safety guardrails for lab simulations.',
          'Explore how multimodal models interpret charts, diagrams, and code snippets.'
        ]
      },
      'Student Help Desk': {
        highlight: 'Prioritize responsiveness, cost efficiency, and available deployment frameworks.',
        recommendations: ['Claude 3 Haiku', 'GPT-3.5', 'Gemini 1.5 Flash'],
        conversation: [
          'Debate API vs. on-premise hosting using open models like Llama 3.',
          'Discuss why distillation enables lighter models for quick answers.',
          'Have students design escalation flow for tricky questions.'
        ]
      },
      'Makerspace & Robotics': {
        highlight: 'Connect open-weight models with customization potential and hardware integrations.',
        recommendations: ['Llama 3 70B', 'Mixtral 8x7B', 'Stable Diffusion XL'],
        conversation: [
          'Compare licensing implications of open vs. closed families.',
          'Map how instruction tuning and fine-tuning differ for hands-on projects.',
          'Prototype a vision + language workflow for robotics narration.'
        ]
      }
    };

    const filters = document.getElementById('filters');
    const gallery = document.getElementById('gallery');
    const timelineSlider = document.getElementById('timeline-slider');
    const timelineValue = document.getElementById('timeline-value');
    const lineageSelect = document.getElementById('lineage-select');
    const lineagePath = document.getElementById('lineage-path');
    const scenarioPills = document.getElementById('scenario-pills');
    const scenarioContent = document.getElementById('scenario-content');
    const termGrid = document.getElementById('term-grid');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    const draggableList = document.getElementById('model-draggables');
    const dropzoneList = document.getElementById('model-dropzones');
    const checkMatchesButton = document.getElementById('check-matches');
    const matchFeedback = document.getElementById('match-feedback');

    let dropzoneElements = [];
    let activeDragModel = '';

    const filterDimensions = {
      Family: models.map(m => m.family),
      Architecture: models.map(m => m.architecture),
      Training: models.flatMap(m => m.training),
      Framework: models.flatMap(m => m.frameworks)
    };

    const uniqueValues = {};
    Object.entries(filterDimensions).forEach(([dimension, values]) => {
      uniqueValues[dimension] = [...new Set(values)].sort();
    });

    const activeFilters = {
      Family: new Set(),
      Architecture: new Set(),
      Training: new Set(),
      Framework: new Set()
    };

    function createFilterChips() {
      Object.entries(uniqueValues).forEach(([dimension, values]) => {
        const groupLabel = document.createElement('div');
        groupLabel.innerHTML = `<strong>${dimension}</strong>`;
        groupLabel.style.width = '100%';
        filters.appendChild(groupLabel);

        values.forEach(value => {
          const chip = document.createElement('button');
          chip.className = 'filter-chip';
          chip.textContent = value;
          chip.dataset.dimension = dimension;
          chip.dataset.value = value;
          chip.addEventListener('click', () => toggleFilter(chip));
          filters.appendChild(chip);
        });
      });
    }

    function toggleFilter(chip) {
      const { dimension, value } = chip.dataset;
      const set = activeFilters[dimension];
      if (set.has(value)) {
        set.delete(value);
        chip.classList.remove('active');
      } else {
        set.add(value);
        chip.classList.add('active');
      }
      renderGallery();
    }

    function matchesFilters(model) {
      return Object.entries(activeFilters).every(([dimension, selected]) => {
        if (selected.size === 0) return true;
        if (dimension === 'Family') return selected.has(model.family);
        if (dimension === 'Architecture') return selected.has(model.architecture);
        if (dimension === 'Training') return model.training.some(t => selected.has(t));
        if (dimension === 'Framework') return model.frameworks.some(f => selected.has(f));
        return true;
      });
    }

    function renderGallery() {
      const cutoff = parseInt(timelineSlider.value, 10);
      gallery.innerHTML = '';
      models
        .filter(model => model.releaseYear <= cutoff)
        .filter(matchesFilters)
        .sort((a, b) => b.releaseYear - a.releaseYear)
        .forEach(model => {
          const card = document.createElement('article');
          card.className = 'model-card';
          card.dataset.year = model.releaseYear;
          card.innerHTML = `
            <h3>${model.name}</h3>
            <p>${model.spotlight}</p>
            <ul>
              <li><strong>Family</strong>: ${model.family}</li>
              <li><strong>Architecture</strong>: ${model.architecture}</li>
              <li><strong>Training</strong>: ${model.training.join(', ')}</li>
              <li><strong>Frameworks</strong>: ${model.frameworks.join(', ')}</li>
            </ul>
          `;
          gallery.appendChild(card);
        });

      if (!gallery.children.length) {
        const emptyState = document.createElement('div');
        emptyState.className = 'model-card';
        emptyState.innerHTML = `
          <h3>No models match… yet!</h3>
          <p>Try relaxing a filter or extending the timeline slider to surface more options.</p>
        `;
        gallery.appendChild(emptyState);
      }
    }

    function setupTimeline() {
      const years = models.map(model => model.releaseYear);
      timelineSlider.min = Math.min(...years);
      timelineSlider.max = Math.max(...years);
      timelineSlider.value = timelineSlider.max;
      timelineValue.textContent = timelineSlider.value;

      timelineSlider.addEventListener('input', () => {
        timelineValue.textContent = timelineSlider.value;
        renderGallery();
      });
    }

    function setupLineage() {
      models
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach(model => {
          const option = document.createElement('option');
          option.value = model.name;
          option.textContent = model.name;
          lineageSelect.appendChild(option);
        });

      lineageSelect.addEventListener('change', () => renderLineage(lineageSelect.value));
      lineageSelect.value = models[0].name;
      renderLineage(lineageSelect.value);
    }

    function renderLineage(modelName) {
      const model = models.find(m => m.name === modelName);
      if (!model) return;
      lineagePath.innerHTML = '';

      model.lineage.forEach((node, index) => {
        const span = document.createElement('span');
        span.className = 'lineage-node';
        if (index === model.lineage.length - 1) {
          span.classList.add('current');
        }
        span.textContent = node;
        lineagePath.appendChild(span);
        if (index < model.lineage.length - 1) {
          const arrow = document.createElement('span');
          arrow.className = 'arrow';
          arrow.textContent = '→';
          lineagePath.appendChild(arrow);
        }
      });
    }

    function renderScenarios() {
      Object.entries(scenarios).forEach(([label, data], index) => {
        const pill = document.createElement('button');
        pill.className = 'scenario-pill';
        pill.textContent = label;
        pill.addEventListener('click', () => {
          document.querySelectorAll('.scenario-pill').forEach(el => el.classList.remove('active'));
          pill.classList.add('active');
          showScenario(label);
        });
        if (index === 0) pill.classList.add('active');
        scenarioPills.appendChild(pill);
      });
      showScenario(Object.keys(scenarios)[0]);
    }

    function showScenario(name) {
      const data = scenarios[name];
      scenarioContent.innerHTML = `
        <div class="scenario-highlight">${data.highlight}</div>
        <div>
          <strong>Spotlight Models:</strong>
          <ul>${data.recommendations.map(model => `<li>${model}</li>`).join('')}</ul>
        </div>
        <div>
          <strong>Discussion Prompts:</strong>
          <ul>${data.conversation.map(item => `<li>${item}</li>`).join('')}</ul>
        </div>
      `;
    }

    function setupTabs() {
      if (!tabButtons.length) return;
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          if (button.classList.contains('active')) return;
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          button.classList.add('active');
          const target = document.getElementById(`${button.dataset.tab}-tab`);
          if (target) {
            target.classList.add('active');
          }
        });
      });
    }

    function setupModelMatch() {
      if (!draggableList || !dropzoneList) return;
      draggableList.innerHTML = '';
      dropzoneList.innerHTML = '';
      if (matchFeedback) matchFeedback.textContent = '';

      const shuffled = [...modelMatch].sort(() => Math.random() - 0.5);

      shuffled.forEach(item => {
        const drag = document.createElement('div');
        drag.className = 'drag-item';
        drag.textContent = item.model;
        drag.draggable = true;
        drag.dataset.model = item.model;
        drag.setAttribute('role', 'button');
        drag.setAttribute('aria-grabbed', 'false');
        drag.addEventListener('dragstart', handleDragStart);
        drag.addEventListener('dragend', handleDragEnd);
        draggableList.appendChild(drag);
      });

      dropzoneElements = modelMatch.map((item, index) => {
        const zone = document.createElement('div');
        zone.className = 'dropzone';
        zone.dataset.answer = item.model;
        zone.dataset.current = '';
        zone.innerHTML = `
          <strong>Hint ${index + 1}</strong>
          <p>${item.hint}</p>
          <span class="drop-placeholder">Drag a model here</span>
        `;
        zone.addEventListener('dragover', handleDragOver);
        zone.addEventListener('dragleave', handleDragLeave);
        zone.addEventListener('drop', handleDrop);
        zone.addEventListener('click', () => clearZone(zone));
        dropzoneList.appendChild(zone);
        return zone;
      });
    }

    function handleDragStart(event) {
      const model = event.target.dataset.model;
      activeDragModel = model;
      event.dataTransfer.setData('text/plain', model);
      event.dataTransfer.effectAllowed = 'move';
      event.target.classList.add('dragging');
    }

    function handleDragEnd(event) {
      event.target.classList.remove('dragging');
      activeDragModel = '';
      dropzoneElements.forEach(zone => zone.classList.remove('drag-over'));
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      event.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(event) {
      event.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(event) {
      event.preventDefault();
      const zone = event.currentTarget;
      zone.classList.remove('drag-over');
      const modelName = event.dataTransfer.getData('text/plain') || activeDragModel;
      if (!modelName) return;
      assignModelToZone(zone, modelName);
    }

    function assignModelToZone(zone, modelName) {
      const dragItem = Array.from(document.querySelectorAll('.drag-item')).find(item => item.dataset.model === modelName);
      if (!dragItem) return;

      if (zone.dataset.current === modelName) return;

      if (zone.dataset.current) {
        const previousItem = Array.from(document.querySelectorAll('.drag-item')).find(item => item.dataset.model === zone.dataset.current);
        if (previousItem) {
          previousItem.classList.remove('assigned');
          previousItem.draggable = true;
          previousItem.setAttribute('aria-grabbed', 'false');
        }
      }

      const occupiedZone = dropzoneElements.find(el => el.dataset.current === modelName);
      if (occupiedZone) {
        clearZone(occupiedZone, true);
      }

      dragItem.classList.add('assigned');
      dragItem.draggable = false;
      dragItem.setAttribute('aria-grabbed', 'true');

      zone.dataset.current = modelName;
      zone.classList.add('filled');
      zone.classList.remove('correct', 'incorrect');
      const placeholder = zone.querySelector('.drop-placeholder');
      if (placeholder) placeholder.textContent = modelName;
      if (matchFeedback) matchFeedback.textContent = '';
    }

    function clearZone(zone, silent = false) {
      const current = zone.dataset.current;
      if (current) {
        const dragItem = Array.from(document.querySelectorAll('.drag-item')).find(item => item.dataset.model === current);
        if (dragItem) {
          dragItem.classList.remove('assigned');
          dragItem.draggable = true;
          dragItem.setAttribute('aria-grabbed', 'false');
        }
      }
      zone.dataset.current = '';
      zone.classList.remove('filled', 'correct', 'incorrect');
      const placeholder = zone.querySelector('.drop-placeholder');
      if (placeholder) placeholder.textContent = 'Drag a model here';
      if (!silent && matchFeedback) {
        matchFeedback.textContent = '';
      }
    }

    function evaluateMatches() {
      if (!dropzoneElements.length) return;
      let correct = 0;
      dropzoneElements.forEach(zone => {
        zone.classList.remove('correct', 'incorrect');
        const current = zone.dataset.current;
        if (current && current === zone.dataset.answer) {
          zone.classList.add('correct');
          correct += 1;
        } else {
          zone.classList.add('incorrect');
        }
      });

      if (correct === modelMatch.length) {
        if (matchFeedback) matchFeedback.textContent = 'Great job! Every hint matches the right model.';
      } else {
        if (matchFeedback) matchFeedback.textContent = `You matched ${correct} of ${modelMatch.length}. Keep exploring the hints and try again.`;
      }
    }
    if (checkMatchesButton) {
      checkMatchesButton.addEventListener('click', evaluateMatches);
    }

    function renderTerminology() {
      terminology.forEach(entry => {
        const card = document.createElement('article');
        card.className = 'term-card';
        card.innerHTML = `
          <h3>${entry.term}</h3>
          <p>${entry.definition}</p>
          <span class="tip">Classroom analogy: ${entry.analogy}</span>
        `;
        termGrid.appendChild(card);
      });
    }

    createFilterChips();
    setupTimeline();
    setupLineage();
    renderGallery();
    renderScenarios();
    setupTabs();
    setupModelMatch();
    renderTerminology();
  </script>
</body>
</html>
